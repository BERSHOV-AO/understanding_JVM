Задача "Понимание JVM"

public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }

}

--------------------------ClassLoader'ы-----------------------------

Application class loader - подгружает класс JvmComprehension (загрузчик верхнего уровня, уровень приложения).
Platform class loader - подгружает классы из пакета java.util. (уровень платформы)
Bootstrap ClassLoader - подгружает файлы из пакета java. (уровень java core)
Три класслоадера, делегируют загрузку классов - разных уровней.
Данная система нужна для определенного порядка загрузки(приоритетов) и для безопасности.

Metaspace (метаданные) — в этой памяти хранятся метаданные классов и статические переменные.

------------------------------main----------------------------------

В стеке создается фрейм для метода main.

--------------------------------1-----------------------------------

Создаем переменную i примитивного типа int.
Присваиваем в переменную i значение 1.
Примитивное значение i типа int будет храниться непосредственно в стеке;

--------------------------------2-----------------------------------

Ссылочная переменная o типа Object будет создана в стеке.
С помощью оператора new создаем экземпляр класса Object()(с default конструктором) в куче(heap),
и возвращаем ссылку на этот объект.
Присваиваем ссылку в ссылочную переменную o.

--------------------------------3-----------------------------------

Ссылочная переменная ii типа Integer будет создана в стеке.
Выделяется память в куче(heap) под новый объект, как будто написали new Integer(2).
Присваиваем ссылку на new Integer(2) в ссылочную переменную ii.

--------------------------------4-----------------------------------

Так как переходим к работе функции printAll(), в стеке добавляется отдельный фрейм printAll().
Передаем в аргументы функции printAll() ссылку на объект o, ссылку на объект ii, и объект iю

--------------------------------5-----------------------------------

Ссылочная переменная uselessVar типа Integer (объект) будет создана в стеке.
Выделяется память в куче(heap) под новый объект, как будто написали new Integer(700).
Присваиваем ссылку на new Integer(700) в ссылочную переменную uselessVar.

--------------------------------6-----------------------------------
Создается новый фрейм для println(), куда передается ссылка на o, ссылка на ii и переменная i, созданные в методе
printAll().
Метод у объекта o.toString() - возвращает строковое представление объекта o.
По умолчанию Object.toString() метод возвращает строку,
состоящую из имени класса, '@' символ, за которым следует беззнаковое
шестнадцатеричное представление хеш-кода объекта (java.lang.Object@7b23ec81).
Далее конкатенируем к нашей строке значение переменой i равное 1, и значение объекта ii = 2,
и получаем строку java.lang.Object@7b23ec8112
С помощью метода System.out.println() выводим сообщение java.lang.Object@7b23ec8112 в консоль.
После отработки System.out.println() фрейм для для println() в стеке уничтожается.

После завершения метода printAll(), фрейм printAll() в стеке уничтожается. Следовательно, уничтожается ссылочные
переменные uselessVar, Object o, Integer ii, и переменная int i.
Garbage collector уничтожает объект из кучи, на который ссылалась uselessVar. Так как он больше нигде не используется.
И ссылки на него уже не существует.

--------------------------------7-----------------------------------

Создается новый фрейм для System.out.println(), куда передается "finished".
Выводим сообщение "finished" на экран и после этого осуществляется перевод курсора на новую строчку.
После отработки System.out.println() данный фрейм уничтожается.



